# 冒泡排序
冒泡排序属于交换排序。交换排序的基本思想是对数据表中的关键字进行比较，如果发生逆序（即排序顺序与排序后的次序正好相反），则两者交换位置，直到所有数据元素都排好序为止。

冒泡排序的基本思想是：设数据表 elem 中有 n 个数据元素，首先数据表中第一、第二个数据元素（elem[0]和elem[1]）进行比较，如果 elem[0]>elem[1]，则交换 elem[0] 和 elem[1];然后对第二、第三个数据元素做同样处理；重复此过程直到处理完最后两个相邻的数据元素。称此过程为一趟冒泡。这样的一趟冒泡将最大或最小的数移到了最后。如此循环将 n-1 此就能将数据元素排序完成。

例如：

我们有一组数组元素为：`99,38,13,77,85,44`。<br/>
第一趟排序过程：
>99 38 13 77 85 44
>38 99 13 77 85 44
>38 13 99 77 85 44
>38 13 77 99 85 44
>38 13 77 85 99 44
>38 13 77 85 44 99

各趟冒泡后的结果为：
>99,38,13,77,85,44
>38 13 77 85 44 99
>13 38 77 44 85 99
>13 38 44 77 85 99

对有 n 个数据表进行排序，最多需要 n-1 次冒泡，但具体到某一个特定的数据表时，可能不需要进行 n-1 趟冒泡，例如上面的例子只需要三趟就能完成排序。所以我们可以在算法中增加一个标志位 finish，用于标志本趟冒泡排序过程中是否发生逆序而进行交换。若进行过交换，则 finish 为 false，表示数据可能没有全部排好序，需要下一次排序；若没有进行过交换，则 finish 为 true,表示全部数据已经排好序，可以结束排序。下面给出冒泡排序的 Java 实现：

    void bulleSort(int elem[]){
      boolean finish=false;//标志位判断是否发生逆序
      //循环 n-1 次就能完成排序
      for(int i=0;i<elem.length-1&&!finish;i++){
        //进行 n-1 次冒泡
        for(int j=1,j<elem.length;j++){
          //若发生逆序则交换位置，并将 finish 设为 false 表示未排序完成
          if(elem[j-1]>elem[j]){
            int a=elem[j];
            elem[j]=elem[j-1];
            elem[j-1]=a;
            finish=false;
          }
        }
      }
    }

对于冒泡排序，当数据元素的初始排列已经按关键字从小到大排好序，此算法只需执行一趟冒泡，进行 n-1 次关键字比较；最坏情况是数据元素是按关键字从大到小排列，此时算法执行 n-1 趟冒泡，第 i 趟做了 n-i 次关键字比较，执行了 n-i 次数据交换。这样最坏情形下总的关键字比较次数为：n(n-1)/2，数据元素移动次数为：3n(n-1)/2。因此最坏情况下时间时间复杂度为O(n²)。
