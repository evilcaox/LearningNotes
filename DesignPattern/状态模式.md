# 状态模式
>定义：允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。

状态模式用于解决系统中复杂对象的状态以及不同状态下行为的封装问题。

## 状态模式的结构
UML 为：<br/>

![状态模式](http://oyqb3fc6x.bkt.clouddn.com/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F.jpg "状态模式")

1. **Context（环境类）：** 环境类又称为上下文类，它是拥有多种状态的对象。由于环境类的状态存在多样性，且在不同状态下对象的行为有所不同，因此将状态独立出去形成单独的状态类。在环境类中维护一个抽象状态类 State 的实例，这个实例定义当前状态，在具体实现时，它是 State 子类的对象。
2. **State（抽象状态类）：** 它用于定义一个接口以封装与环境类的一个特定状态相关的行为，在抽象状态类中声明了各种不同状态对应的方法，而在其子类中实现了这些方法，由于不同状态下对象的行为可能不同，因此在不同子类中方法的实现可能存在不同，相同的方法可以写在抽象状态中。
3. **ConcreteState（具体状态类）：** 它是抽象状态类的子类，每一个具体状态类实现一个与环境类的一个状态相关的行为，对应环境类的一个具体状态，不同的具体状态类其行为有所不同。

## 状态模式的实现
1. State
<pre>
abstract class State{
  public abstract void handle();
}
</pre>

2. ConcreteState
<pre>
public class ConcreteState extends State{
  public void handle(){
    //具体业务的实现
  }
}
</pre>

3. Context
<pre>
public class Context{
  private State state;//维持一个对抽象状态对象的引用
  private int value;//其他属性值，该属性值的变化可能会导致对象的状态发生变化
  //设置状态对象
  public void setState(State state){
    this.state=state;
  }
  public void request(){
    //其他代码
    state.request();//调用适合对象的业务方法
  }
}
</pre>

在状态模式的使用过程中，对象的状态可以进行相互转换，通常有两种方法实现状态转换的方式。
* 统一由环境类来负责状态之间的转换，此时，环境类还充当了状态管理器角色，在环境类的业务方法中通过对某些属性值的判断实现状态转换，也可以提供一个专门的方法用于实现属性判断和状态转换。代码如下：
<pre>
public void changeState(){
  //判读属性值，根据属性值进行状态转换
  if(value==0){
    this.setState(new ConcreteStateA());
  }else if(value==1){
    this.setState(new ConcreteStateB());
  }
  ...
}
</pre>

* 由具体状态类来负责状态之间的转换，可以在具体状态类的业务方法中判断环境类的某些属性值，再根据情况为环境类设置新的状态对象，实现状态转换。同样，也可以提供一个专门的方法来负责属性值的判断和状态转换。此时，状态类与环境类之间将存在依赖或关联关系，因为状态类需要访问环境类中的属性值，具体状态类 ConcreteState 的代码片段如下。
<pre>
public void changeState(Context context){
  //根据环境对象中的属性值进行状态转换
  if(context.value==1){
    context.setState(new ConcreteStateA());
  }else if(context.value){
    context.setState(new ConcreteStateB());
  }
  ...
}
</pre>

## 状态模式的适用环境
1. 对象的行为依赖于它的状态（例如某些属性值），状态的改变将导致行为的变化
2. 在代码中包含大量与对象状态有关的条件语句，这些条件语句的出现会导致代码的可维护性和灵活性变差，不能方便地增加和删除状态，并且导致客户类与类库之间的耦合增强

## 优点
1. 封装了状态的转换规则，可以对状态转换代码进行集中管理，而不是分散在一个个业务方法中
2. 将所有与某个状态有关的行为放到一个类中，只需要注入一个不同的状态对象即可使环境对象拥有不同的行为
3. 允许状态转换逻辑与状态对象合成一体，而不是提供一个巨大的条件语句块，可以避免使用庞大的条件语句来将业务方法和状态转换代码交织在一起
4. 可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数

## 缺点
1. 会增加系统中类和对象的个数，导致系统运行开销增大
2. 结构与实现都较为复杂，如果使用不当将导致程序结构和代码混乱，增加系统设计的难度
3. 对开闭原则的支持并不太好，增加新的状态类需要修改负责状态转换的源代码，否则无法转换到新增状态；而且修改某个状态类的行为也需要修改对应类的源代码
