# 策略模式
>定义：定义了一系列算法，将每一个算法封装起来，并让他们可以相互替换。策略模式让算法可以独立于使用它的客户变化。

在策略模式中，可以定义一些独立的类来封装不同的算法，每一个类封装一种具体算法，在这里，每一个封装算法的类都可以称为一种策略，为了保证这些策略在使用时具有一致性，一般会提供一个抽象的策略类来做算法的声明，而每种算法则对应于一个具体策略类。

## 策略模式的结构
UML 为：<br/>

![策略模式](http://oyqb3fc6x.bkt.clouddn.com/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F.jpg "策略模式")

1. **Context（环境类）：** 环境类是使用算法的角色，它是解决某个问题（即实现某个功能）时可以采用多种策略。在环境类中维持一个对抽象策略类的引用实例，用于定义所采用的策略。
2. **Strategy（抽象策略类）：** 抽象策略类为所支持的算法声明了抽象方法，是所有策略类的父类，它可以是抽象类或具体类，也可以是接口。
3. **ConcreteStrategy（具体策略类）：** 具体策略类实现了在抽象策略类中声明的算法，在运行时，具体策略类对象将覆盖在环境中定义的抽象策略类对象，使用一种具体的算法实现某个业务功能。

## 策略模式的实现
1. Strategy
<pre>
abstract class Strategy{
  public abstract void algorithm();//声明抽象算法
}
</pre>

2. ConcreteStrategy
<pre>
public class ConcreteStrategy extends Strategy{
  //算法的具体实现
  public void algorithm(){
    //算法实现
  }
}
</pre>

3. Context
<pre>
public class Context{
  private Strategy strategy;//维持一个对抽象策略类的引用
  public void setStrategy(Strategy strategy){
    this.strategy=strategy;
  }
  //调用策略类中的算法
  publc void algorithm(){
    strategy.algorithm();
  }
}
</pre>

## 适用环境
1. 一个系统需要动态地在几种算法中选择一种
2. 避免使用难以维护的多重条件选择语句
3. 不希望客户端知道复杂的、与算法相关的数据结构，提高算法的保密性与安全性

## 优点
1. 提供了对开闭原则的完美支持，用户可以在不修改原有系统的基础上选择算法或行为，也可以灵活地增加新的算法或行为
2. 提供了管理相关的算法族的办法
3. 提供了一种可以替换继承关系的办法
4. 可以避免多重条件选择语句
5. 提供了一种算法的复用机制，不同的环境类可以方便地复用策略类

## 缺点
1. 客户端必须知道所有的策略类，并自行决定使用哪一个策略类
2. 将造成系统产生很多具体策略类
3. 无法同时在客户端使用多个策略类
